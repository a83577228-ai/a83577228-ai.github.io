<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <!-- æ ¸å¿ƒè§†å£è®¾ç½® -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    
    <!-- iOS PWA ä¸“å±è®¾ç½® -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="æ—‹å¾‹å¬å†™">
    
    <title>æ—‹å¾‹èµ°å‘å¬å†™æµ‹è¯•</title>
    <style>
        :root {
            --primary-color: #007AFF;
            --success-color: #34C759;
            --danger-color: #FF3B30;
            --bg-color: #F2F2F7;
            --card-bg: #FFFFFF;
            --text-color: #000000;
            --overlay-bg: rgba(0, 0, 0, 0.4);
        }

        * { -webkit-touch-callout: none; -webkit-user-select: none; user-select: none; }

        html, body {
            margin: 0; padding: 0; width: 100%; height: 100dvh;
            background-color: var(--bg-color);
            font-family: -apple-system, BlinkMacSystemFont, "SF Pro Text", "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            overflow: hidden; touch-action: none; color: var(--text-color);
        }

        .app-layout {
            display: flex; flex-direction: column; height: 100%; width: 100%; max-width: 100%;
            padding-top: max(15px, env(safe-area-inset-top));
            padding-bottom: max(20px, env(safe-area-inset-bottom));
            padding-left: max(15px, env(safe-area-inset-left));
            padding-right: max(15px, env(safe-area-inset-right));
            box-sizing: border-box;
        }

        /* é¡¶éƒ¨å¯¼èˆªæ  */
        .nav-bar {
            display: flex; align-items: center; justify-content: space-between;
            height: 44px; padding: 0 10px; flex-shrink: 0; margin-bottom: 5px; position: relative;
        }

        .menu-btn, .func-btn {
            background: none; border: none; padding: 0; cursor: pointer;
            display: flex; align-items: center; justify-content: center;
            border-radius: 8px; transition: background 0.2s; color: #333;
            width: 44px; height: 44px;
        }
        .menu-btn:active, .func-btn:active { background: rgba(0,0,0,0.1); }
        .menu-icon, .func-icon { width: 24px; height: 24px; fill: currentColor; }

        /* é¡¶éƒ¨æ ‡é¢˜ä¸è®¡åˆ†æ¿ */
        .title-container {
            display: flex; flex-direction: column; align-items: center;
            position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%);
            pointer-events: none;
        }
        .app-title { font-size: 16px; font-weight: 600; color: #000; line-height: 1.2; }
        .score-board { 
            font-size: 12px; color: #666; font-weight: 500; margin-top: 2px; 
            background: rgba(0,0,0,0.05); padding: 2px 8px; border-radius: 10px;
            display: none; /* é»˜è®¤éšè—ï¼Œå¼€å¯é¢˜ç›®æ•°é‡é™åˆ¶æ—¶æ˜¾ç¤º */
        }

        /* ç”»å¸ƒåŒºåŸŸ */
        .canvas-area {
            flex: 1; position: relative; background: #fff; border-radius: 16px;
            box-shadow: 0 2px 12px rgba(0,0,0,0.08); overflow: hidden;
            margin-bottom: 15px; min-height: 0; touch-action: none;
        }
        canvas { width: 100%; height: 100%; display: block; cursor: crosshair; }

        .placeholder-text {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #8E8E93; pointer-events: none; font-size: 15px; font-weight: 500; text-align: center;
        }

        .legend-overlay {
            position: absolute; bottom: 10px; left: 0; width: 100%;
            display: flex; justify-content: center; gap: 20px;
            font-size: 12px; color: #666; background: rgba(255,255,255,0.85);
            backdrop-filter: blur(10px); padding: 6px 0; pointer-events: none;
            border-top: 1px solid rgba(0,0,0,0.05);
        }
        .dot { width: 8px; height: 8px; border-radius: 50%; display: inline-block; margin-right: 4px; vertical-align: middle; }

        /* åº•éƒ¨æ“ä½œæ  */
        .action-bar {
            position: relative; display: flex; align-items: center; height: 56px; flex-shrink: 0;
            padding: 0 5px; 
        }
        .main-actions { display: flex; gap: 12px; flex: 1; justify-content: center; width: 100%; }

        .btn {
            flex: 1; border: none; border-radius: 14px; font-size: 17px; font-weight: 600;
            cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 6px;
            transition: transform 0.1s, opacity 0.2s; padding: 0 15px; height: 54px;
            -webkit-tap-highlight-color: transparent;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }
        .btn:active { transform: scale(0.96); opacity: 0.9; }
        .btn-primary { background-color: var(--primary-color); color: white; }
        .btn-success { background-color: var(--success-color); color: white; }
        .btn-next { background-color: #5856D6; color: white; display: none; }
        .btn:disabled { background-color: #E5E5EA; color: #999; box-shadow: none; cursor: not-allowed; }

        /* å¼¹çª— */
        .modal-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.5); backdrop-filter: blur(3px); z-index: 2000;
            display: flex; align-items: center; justify-content: center;
            opacity: 0; pointer-events: none; transition: opacity 0.25s ease;
        }
        .modal-overlay.show { opacity: 1; pointer-events: auto; }

        .modal-panel {
            background: #fff; width: 88%; max-width: 340px; max-height: 80vh;
            border-radius: 20px; box-shadow: 0 20px 40px rgba(0,0,0,0.2);
            padding: 20px; transform: scale(0.95); transition: transform 0.25s cubic-bezier(0.34, 1.56, 0.64, 1);
            display: flex; flex-direction: column; gap: 15px; overflow: hidden;
        }
        .modal-overlay.show .modal-panel { transform: scale(1); }

        .modal-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px; flex-shrink: 0; }
        .modal-title { font-size: 20px; font-weight: 700; display: flex; align-items: center; gap: 8px;}
        .close-btn {
            background: #F2F2F7; border: none; width: 32px; height: 32px;
            border-radius: 50%; color: #8E8E93; font-size: 20px; line-height: 1;
            display: flex; align-items: center; justify-content: center; cursor: pointer;
        }

        .settings-content, .mistakes-list { overflow-y: auto; -webkit-overflow-scrolling: touch; flex: 1; }
        .settings-content { display: flex; flex-direction: column; gap: 12px; padding-bottom: 10px; }
        .mistakes-list { display: flex; flex-direction: column; gap: 10px; padding: 2px; }
        
        /* ç»“æœå¼¹çª—ç‰¹åˆ«æ ·å¼ */
        .result-score { font-size: 48px; font-weight: 800; color: var(--primary-color); text-align: center; margin: 10px 0; }
        .result-detail { text-align: center; color: #666; font-size: 16px; margin-bottom: 20px; }

        .mistake-item {
            background: #F9F9F9; padding: 15px; border-radius: 12px; display: flex; justify-content: space-between; align-items: center;
            border: 1px solid rgba(0,0,0,0.05); transition: background 0.2s;
        }
        .mistake-item:active { background: #F0F0F0; }
        .mistake-info { display: flex; flex-direction: column; gap: 4px; cursor: pointer; flex: 1;}
        .mistake-title { font-size: 16px; font-weight: 600; color: #000; }
        .mistake-meta { font-size: 13px; color: #888; }
        .mistake-delete {
            padding: 8px 12px; color: var(--danger-color); background: none; border: none; font-size: 15px; cursor: pointer; font-weight: 500;
        }
        .empty-state { text-align: center; color: #999; padding: 40px 0; font-size: 15px; }
        
        .practice-all-btn {
            background-color: #007AFF; color: white; border: none; border-radius: 14px;
            padding: 6px 12px; font-size: 13px; font-weight: 600; cursor: pointer;
        }

        /* æ§ä»¶æ ·å¼ */
        .control-group { background: #F9F9F9; padding: 10px 14px; border-radius: 12px; display: flex; flex-direction: column; gap: 8px; }
        .control-row { display: flex; align-items: center; justify-content: space-between; }
        label { font-size: 15px; font-weight: 500; color: #000; }

        .stepper { display: flex; align-items: center; background: #fff; border: 0.5px solid rgba(0,0,0,0.1); border-radius: 8px; padding: 2px; box-shadow: 0 1px 2px rgba(0,0,0,0.05); }
        .stepper button { background: transparent; border: none; width: 36px; height: 30px; font-size: 18px; color: #007AFF; font-weight: 600; }
        .stepper span { width: 40px; text-align: center; font-weight: 600; font-size: 15px; font-variant-numeric: tabular-nums; }
        .stepper.wide-stepper span { width: 90px; font-size: 14px; }

        .dual-picker-wrapper {
            display: flex; height: 110px; position: relative;
            background: #fff; border: 0.5px solid rgba(0,0,0,0.1); border-radius: 12px; overflow: hidden;
        }
        .picker-highlight-bar {
            position: absolute; top: 38px; left: 0; right: 0; height: 34px;
            background: rgba(0,0,0,0.04); border-top: 0.5px solid rgba(0,0,0,0.1); border-bottom: 0.5px solid rgba(0,0,0,0.1); pointer-events: none; z-index: 5;
        }
        .picker-column { flex: 1; height: 100%; position: relative; text-align: center; }
        .picker-labels { display: flex; justify-content: space-between; padding: 0 10px; margin-bottom: -4px; font-size: 12px; color: #888; font-weight: 500;}
        .picker-scroller {
            height: 100%; overflow-y: auto; scroll-snap-type: y mandatory;
            padding: 38px 0; box-sizing: content-box; scrollbar-width: none; touch-action: pan-y; 
        }
        .picker-scroller::-webkit-scrollbar { display: none; }
        .picker-item {
            height: 34px; display: flex; align-items: center; justify-content: center;
            font-size: 16px; color: #000; scroll-snap-align: center; opacity: 0.3; transition: opacity 0.2s, transform 0.2s;
        }
        .picker-item.active { opacity: 1; font-weight: 600; transform: scale(1.05); }

        .toast {
            position: fixed; bottom: 100px; left: 50%; transform: translateX(-50%);
            background: rgba(50,50,50,0.9); color: white; padding: 12px 24px; border-radius: 30px;
            font-size: 15px; font-weight: 500; pointer-events: none; opacity: 0; transition: opacity 0.3s; z-index: 3000;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15); backdrop-filter: blur(10px);
        }
        .toast.show { opacity: 1; }
        .toast.correct { background: rgba(52, 199, 89, 0.9); }
        .toast.wrong { background: rgba(255, 59, 48, 0.9); }
        
        .practice-indicator {
            background-color: #FF9500; color: white; font-size: 11px; padding: 3px 8px; border-radius: 6px;
            margin-left: 8px; display: none; font-weight: 600; vertical-align: middle;
        }

        @media (orientation: landscape) {
            .app-layout { flex-direction: row; gap: 15px; padding-top: max(10px, env(safe-area-inset-top)); padding-bottom: max(10px, env(safe-area-inset-bottom)); }
            .nav-bar { flex-direction: column; height: 100%; width: 44px; justify-content: space-between; padding: 0; margin: 0; }
            .title-container { display: none; } /* æ¨ªå±ä¸æ˜¾ç¤ºæ ‡é¢˜ä»¥èŠ‚çœç©ºé—´ */
            .canvas-area { margin-bottom: 0; height: 100%; }
            .action-bar { flex-direction: column; height: 100%; width: 70px; padding: 5px 0; }
            .main-actions { flex-direction: column; justify-content: flex-end; width: 100%; margin-left: 0; margin-top: 10px; gap: 10px; }
            .btn { width: 100%; flex: 1; font-size: 13px; flex-direction: column; padding: 5px; height: auto; }
            .btn svg { margin-bottom: 4px; }
        }
    </style>
</head>
<body>

<div class="app-layout">
    <!-- é¡¶éƒ¨å¯¼èˆªæ  -->
    <div class="nav-bar">
        <!-- å·¦ä¸Šè§’ï¼šè®¾ç½®é”® -->
        <button class="menu-btn" id="btn-open-settings">
            <svg class="menu-icon" viewBox="0 0 24 24"><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg>
        </button>
        
        <!-- æ ‡é¢˜ä¸è®¡åˆ†æ¿ -->
        <div class="title-container">
            <div class="app-title">
                æ—‹å¾‹å¬å†™
                <span id="practice-badge" class="practice-indicator">å¤ä¹ æ¨¡å¼</span>
            </div>
            <div class="score-board" id="score-board">
                è¿›åº¦: 1/10 | æ­£ç¡®: 0
            </div>
        </div>
        
        <!-- å³ä¸Šè§’ï¼šåŠŸèƒ½é”® (é”™é¢˜é›†) -->
        <button class="func-btn" id="btn-open-mistakes">
            <svg class="func-icon" viewBox="0 0 24 24"><path d="M6 10c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm12 0c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm-6 0c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z"/></svg>
        </button>
    </div>

    <!-- ç”»å¸ƒåŒºåŸŸ -->
    <div class="canvas-area" id="canvas-container">
        <canvas id="melodyCanvas"></canvas>
        <div class="placeholder-text" id="status-text">ç‚¹å‡»æ’­æ”¾å¼€å§‹</div>
        <div class="legend-overlay">
            <span><span class="dot" style="background: var(--primary-color);"></span>æˆ‘çš„</span>
            <span><span class="dot" style="background: var(--success-color);"></span>ç­”æ¡ˆ</span>
        </div>
    </div>

    <!-- åº•éƒ¨/å³ä¾§ æ“ä½œæ  -->
    <div class="action-bar">
        <div class="main-actions">
            <button id="btn-play" class="btn btn-primary">
                <svg width="24" height="24" fill="currentColor" viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg>
                <span id="btn-play-text">æ’­æ”¾</span>
            </button>

            <button id="btn-check" class="btn btn-success" disabled>
                <svg width="24" height="24" fill="currentColor" viewBox="0 0 24 24"><path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z"/></svg>
                éªŒè¯
            </button>

            <button id="btn-next" class="btn btn-next">
                <svg width="24" height="24" fill="currentColor" viewBox="0 0 24 24"><path d="M6 18l8.5-6L6 6v12zM16 6v12h2V6h-2z"/></svg>
                ä¸‹ä¸€é¢˜
            </button>
        </div>
    </div>
</div>

<!-- è®¾ç½®å¼¹çª— -->
<div class="modal-overlay" id="settings-modal">
    <div class="modal-panel">
        <div class="modal-header">
            <div class="modal-title">è®¾ç½®</div>
            <button class="close-btn" id="btn-close-settings">Ã—</button>
        </div>
        <div class="settings-content">
            <!-- é¢˜ç›®æ•°é‡ (æ–°å¢) -->
            <div class="control-group">
                <div class="control-row">
                    <label>é¢˜ç›®æ•°é‡</label>
                    <div class="stepper wide-stepper">
                        <button id="btn-qcount-prev">â€¹</button>
                        <span id="qcount-display">æ— é™</span>
                        <button id="btn-qcount-next">â€º</button>
                    </div>
                </div>
            </div>

            <div class="control-group">
                <div class="control-row">
                    <label>éŸ³è‰²</label>
                    <div class="stepper wide-stepper">
                        <button id="btn-inst-prev">â€¹</button>
                        <span id="instrument-display">é’¢ç´</span>
                        <button id="btn-inst-next">â€º</button>
                    </div>
                </div>
            </div>
            
            <div class="control-group">
                <div class="control-row">
                    <label>èŠ‚å¥æ¨¡å¼</label>
                    <div class="stepper wide-stepper">
                        <button id="btn-rhythm-prev">â€¹</button>
                        <span id="rhythm-display">æ— </span>
                        <button id="btn-rhythm-next">â€º</button>
                    </div>
                </div>
            </div>

            <div class="control-group">
                <div class="control-row">
                    <label>éŸ³ç¬¦æ•°é‡</label>
                    <div class="stepper">
                        <button id="btn-decrease">âˆ’</button>
                        <span id="note-count-display">5</span>
                        <button id="btn-increase">+</button>
                    </div>
                </div>
            </div>
            <div class="control-group">
                <div class="control-row">
                    <label>æœ€å¤§è·³è·ƒ</label>
                    <div class="stepper">
                        <button id="btn-jump-decrease">âˆ’</button>
                        <span id="jump-display">4åº¦</span>
                        <button id="btn-jump-increase">+</button>
                    </div>
                </div>
            </div>
            <div class="control-group">
                <div class="picker-labels">
                    <span class="picker-label">æœ€ä½éŸ³</span>
                    <span class="picker-label">æœ€é«˜éŸ³</span>
                </div>
                <div class="dual-picker-wrapper">
                    <div class="picker-highlight-bar"></div>
                    <div class="picker-column">
                        <div class="picker-scroller" id="picker-start"></div>
                    </div>
                    <div class="picker-column" style="border-left: 1px solid #eee;">
                        <div class="picker-scroller" id="picker-end"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- é”™é¢˜é›†å¼¹çª— -->
<div class="modal-overlay" id="mistakes-modal">
    <div class="modal-panel">
        <div class="modal-header">
            <div class="modal-title">
                é”™é¢˜é›†
                <button class="practice-all-btn" id="btn-practice-all" style="display:none; margin-left:10px;">å…¨éƒ¨ç»ƒä¹ </button>
            </div>
            <button class="close-btn" id="btn-close-mistakes">Ã—</button>
        </div>
        <div class="mistakes-list" id="mistakes-list-container">
            <!-- JS Populate -->
        </div>
    </div>
</div>

<!-- ç»“æœå¼¹çª— -->
<div class="modal-overlay" id="result-modal">
    <div class="modal-panel" style="align-items: center; text-align: center;">
        <div class="modal-header" style="width:100%; justify-content:center;">
            <div class="modal-title">ğŸ‰ æµ‹è¯•å®Œæˆ</div>
        </div>
        <div class="result-score" id="result-score-text">90%</div>
        <div class="result-detail" id="result-detail-text">ç­”å¯¹ 9 é¢˜ / å…± 10 é¢˜</div>
        <button class="btn btn-primary" style="width: 100%;" onclick="closeResultModal()">ç¡®å®š</button>
    </div>
</div>

<!-- Toast -->
<div class="toast" id="toast-msg">å·²åŠ å…¥é”™é¢˜é›†</div>

<script>
    /** Audio Engine (Sampling + Synthesis Fallback) */
    const AudioEngine = {
        ctx: null, masterGain: null, compressorNode: null, reverbNode: null, reverbBufferCache: null,
        activeNodes: [], samples: {}, sampleBaseUrl: 'https://gleitz.github.io/midi-js-soundfonts/FluidR3_GM/',
        instruments: [
            { id: 'piano', name: 'é’¢ç´', file: 'acoustic_grand_piano' },
            { id: 'guitar', name: 'å‰ä»–', file: 'acoustic_guitar_nylon' },
            { id: 'ukulele', name: 'å°¤å…‹é‡Œé‡Œ', file: 'acoustic_guitar_steel' },
            { id: 'bass', name: 'è´æ–¯', file: 'acoustic_bass' }
        ],
        currentInstIndex: 0, isLoading: false,

        init: async function() {
            let contextReset = false;
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            if (!this.ctx || this.ctx.state === 'closed') { this.ctx = new AudioContext(); contextReset = true; }
            if (this.ctx.state === 'suspended') { try { await this.ctx.resume(); } catch (e) { this.ctx = new AudioContext(); contextReset = true; } }
            if (contextReset || !this.compressorNode) { await this.buildAudioGraph(); }
            this.loadCurrentInstrumentSamples();
        },
        buildAudioGraph: async function() {
            if (!this.ctx) return;
            this.compressorNode = this.ctx.createDynamicsCompressor();
            this.compressorNode.threshold.value = -24; this.compressorNode.knee.value = 30; this.compressorNode.ratio.value = 12; this.compressorNode.attack.value = 0.003; this.compressorNode.release.value = 0.25;
            this.reverbNode = this.ctx.createConvolver();
            if (!this.reverbBufferCache) { this.reverbBufferCache = this.createReverbBuffer(2.0); }
            this.reverbNode.buffer = this.reverbBufferCache;
            const reverbGain = this.ctx.createGain(); reverbGain.gain.value = 0.3; this.reverbNode.connect(reverbGain);
            this.masterGain = this.ctx.createGain(); this.masterGain.gain.value = 0.8;
            this.compressorNode.connect(this.masterGain); this.compressorNode.connect(this.reverbNode); reverbGain.connect(this.masterGain);
            this.masterGain.connect(this.ctx.destination);
        },
        createReverbBuffer: function(duration) {
            const rate = this.ctx.sampleRate; const len = rate * duration; const buff = this.ctx.createBuffer(2, len, rate);
            for (let c = 0; c < 2; c++) { const data = buff.getChannelData(c); for (let i = 0; i < len; i++) { data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / len, 2); } }
            return buff;
        },
        stopAll: function() {
            this.activeNodes.forEach(node => { try { node.stop(); node.disconnect(); } catch(e) {} });
            this.activeNodes = [];
        },
        loadCurrentInstrumentSamples: async function() {
            const inst = this.instruments[this.currentInstIndex];
            if (this.samples[inst.id]) return;
            this.isLoading = true;
            const anchors = { 36: 'C2', 48: 'C3', 60: 'C4', 72: 'C5', 84: 'C6', 96: 'C7' };
            this.samples[inst.id] = {};
            const promises = Object.entries(anchors).map(async ([midi, note]) => {
                try {
                    const resp = await fetch(`${this.sampleBaseUrl}${inst.file}-mp3/${note}.mp3`);
                    const arrayBuf = await resp.arrayBuffer();
                    this.samples[inst.id][midi] = await this.ctx.decodeAudioData(arrayBuf);
                } catch (e) {}
            });
            await Promise.all(promises);
            this.isLoading = false;
        },
        ensureSamplesLoaded: async function() {
            if (this.isLoading) { while(this.isLoading) { await new Promise(r => setTimeout(r, 100)); } }
            else if (!this.samples[this.instruments[this.currentInstIndex].id]) { await this.loadCurrentInstrumentSamples(); }
        },
        playTone: function(midi, time, duration, velocity = 1.0) {
            if (!this.compressorNode) return;
            const instId = this.instruments[this.currentInstIndex].id;
            const bank = this.samples[instId];
            if (bank && Object.keys(bank).length > 0) {
                let bestDiff = Infinity; let baseMidi = -1;
                Object.keys(bank).forEach(k => { const diff = Math.abs(midi - k); if (diff < bestDiff) { bestDiff = diff; baseMidi = parseInt(k); } });
                if (baseMidi !== -1) {
                    const src = this.ctx.createBufferSource(); src.buffer = bank[baseMidi];
                    const semitoneDiff = midi - baseMidi; src.playbackRate.value = Math.pow(2, semitoneDiff / 12);
                    const gain = this.ctx.createGain(); gain.gain.setValueAtTime(0, time);
                    const peakGain = 1.0 * velocity;
                    gain.gain.linearRampToValueAtTime(peakGain, time + 0.02); 
                    gain.gain.exponentialRampToValueAtTime(0.01, time + duration + 1.5);
                    src.connect(gain); gain.connect(this.compressorNode); src.start(time); src.stop(time + duration + 2.0);
                    this.activeNodes.push(src);
                    src.onended = () => { const idx = this.activeNodes.indexOf(src); if (idx > -1) this.activeNodes.splice(idx, 1); };
                    return;
                }
            }
            this.playSynthFallback(midi, time, duration, velocity);
        },
        playSynthFallback: function(midi, time, duration, velocity = 1.0) {
            const freq = 440 * Math.pow(2, (midi - 69) / 12);
            const instId = this.instruments[this.currentInstIndex].id;
            const osc = this.ctx.createOscillator(); const gain = this.ctx.createGain();
            if (instId === 'bass') {
                osc.type = 'sawtooth';
                const filter = this.ctx.createBiquadFilter(); filter.type = 'lowpass'; filter.frequency.setValueAtTime(freq * 4, time); filter.frequency.exponentialRampToValueAtTime(freq, time + 0.2);
                osc.connect(filter); filter.connect(gain);
            } else { osc.type = 'triangle'; osc.connect(gain); }
            osc.frequency.value = freq;
            gain.gain.setValueAtTime(0, time); gain.gain.linearRampToValueAtTime(0.5 * velocity, time + 0.05); gain.gain.exponentialRampToValueAtTime(0.01, time + duration);
            gain.connect(this.compressorNode); osc.start(time); osc.stop(time + duration + 0.5);
            this.activeNodes.push(osc);
            osc.onended = () => { const idx = this.activeNodes.indexOf(osc); if (idx > -1) this.activeNodes.splice(idx, 1); };
        },
        changeInstrument: function(delta) {
            let n = this.currentInstIndex + delta; if (n < 0) n = this.instruments.length - 1; if (n >= this.instruments.length) n = 0;
            this.currentInstIndex = n; this.loadCurrentInstrumentSamples(); return this.instruments[n].name;
        }
    };

    function playTickSound() {
        if (!AudioEngine.ctx) AudioEngine.init();
        const ctx = AudioEngine.ctx; if (!ctx) return;
        const t = ctx.currentTime; const buffer = ctx.createBuffer(1, ctx.sampleRate * 0.005, ctx.sampleRate);
        const data = buffer.getChannelData(0); for (let i = 0; i < buffer.length; i++) data[i] = Math.random() * 2 - 1;
        const noise = ctx.createBufferSource(); noise.buffer = buffer;
        const filter = ctx.createBiquadFilter(); filter.type = 'highpass'; filter.frequency.value = 1200; 
        const gain = ctx.createGain(); gain.gain.setValueAtTime(0.3, t); gain.gain.exponentialRampToValueAtTime(0.01, t + 0.005);
        noise.connect(filter); filter.connect(gain); gain.connect(ctx.destination); noise.start(t);
    }

    /** Core Data & State */
    const PIANO_KEYS = []; const NOTE_NAMES = ['C', 'Câ™¯', 'D', 'Dâ™¯', 'E', 'F', 'Fâ™¯', 'G', 'Gâ™¯', 'A', 'Aâ™¯', 'B'];
    for (let m = 21; m <= 108; m++) { const noteName = NOTE_NAMES[m % 12]; const octave = Math.floor(m / 12) - 1; PIANO_KEYS.push({ midi: m, label: `${noteName}${octave}` }); }
    const FULL_SCALE = []; for (let m = 21; m <= 108; m++) { const pc = m % 12; if ([0, 2, 4, 5, 7, 9, 11].includes(pc)) FULL_SCALE.push(m); }

    const RHYTHM_MODES = [ { name: "æ— ", id: 'none' }, { name: "2æ‹å­", id: '2/4' }, { name: "3æ‹å­", id: '3/4' }, { name: "4æ‹å­", id: '4/4' }, { name: "åæ‹", id: 'offbeat' } ];
    // é¢˜ç›®æ•°é‡é€‰é¡¹
    const QUESTION_COUNTS = [ { val: Infinity, label: "æ— é™" }, { val: 10, label: "10é¢˜" }, { val: 20, label: "20é¢˜" }, { val: 50, label: "50é¢˜" } ];
    let currentQCountIndex = 0;

    let noteCount = 5; let startMidi = 48; let endMidi = 72; let maxJumpDegree = 4;
    let currentRhythmIndex = 0;
    let melodyNotes = []; let userPoints = []; let isGameActive = false; let isRevealed = false;
    let mistakeList = JSON.parse(localStorage.getItem('melody_mistakes') || '[]');
    let isPracticeMode = false; let practiceIndex = 0;
    let currentMelodyRhythmMode = 'none';
    let playSessionId = 0;
    
    // è®¡åˆ†æ¿çŠ¶æ€
    let sessionTotal = Infinity;
    let sessionCurrent = 0;
    let sessionCorrect = 0;

    /** DOM Elements */
    const canvas = document.getElementById('melodyCanvas'); const ctx = canvas.getContext('2d');
    const container = document.getElementById('canvas-container'); const statusText = document.getElementById('status-text');
    const displayCount = document.getElementById('note-count-display'); const displayJump = document.getElementById('jump-display');
    const displayInst = document.getElementById('instrument-display'); const displayRhythm = document.getElementById('rhythm-display');
    const displayQCount = document.getElementById('qcount-display');
    const settingsModal = document.getElementById('settings-modal'); const mistakesModal = document.getElementById('mistakes-modal');
    const resultModal = document.getElementById('result-modal');
    const btnPlay = document.getElementById('btn-play'); const btnPlayText = document.getElementById('btn-play-text');
    const btnCheck = document.getElementById('btn-check'); const btnNext = document.getElementById('btn-next');
    const toastMsg = document.getElementById('toast-msg');
    const practiceBadge = document.getElementById('practice-badge');
    const btnPracticeAll = document.getElementById('btn-practice-all');
    const scoreBoard = document.getElementById('score-board');

    function showToast(msg, type = '') {
        toastMsg.textContent = msg; 
        toastMsg.className = 'toast show ' + type;
        setTimeout(() => toastMsg.className = 'toast', 1500);
    }

    /** Logic */
    function resizeCanvas() {
        const rect = container.getBoundingClientRect(); const dpr = window.devicePixelRatio || 1;
        canvas.width = rect.width * dpr; canvas.height = rect.height * dpr;
        ctx.scale(dpr, dpr); canvas.logicalWidth = rect.width; canvas.logicalHeight = rect.height;
        drawCanvas();
    }
    let resizeTimeout;
    window.addEventListener('resize', () => { clearTimeout(resizeTimeout); resizeTimeout = setTimeout(resizeCanvas, 100); });
    document.body.addEventListener('touchstart', function() { if (AudioEngine.ctx && AudioEngine.ctx.state === 'suspended') { AudioEngine.ctx.resume(); } }, {capture: true, once: false});

    document.getElementById('btn-open-settings').addEventListener('click', () => {
        settingsModal.classList.add('show');
        setTimeout(() => {
            const startIdx = PIANO_KEYS.findIndex(k => k.midi === startMidi); const endIdx = PIANO_KEYS.findIndex(k => k.midi === endMidi);
            document.getElementById('picker-start').scrollTop = startIdx * 34; document.getElementById('picker-end').scrollTop = endIdx * 34;
        }, 50);
    });
    document.getElementById('btn-close-settings').addEventListener('click', () => settingsModal.classList.remove('show'));
    
    document.getElementById('btn-open-mistakes').addEventListener('click', () => { renderMistakes(); mistakesModal.classList.add('show'); });
    document.getElementById('btn-close-mistakes').addEventListener('click', () => mistakesModal.classList.remove('show'));
    
    btnPracticeAll.addEventListener('click', () => {
        if (mistakeList.length === 0) return;
        isPracticeMode = true; practiceIndex = 0; practiceBadge.style.display = 'inline-block';
        mistakesModal.classList.remove('show'); loadMistake(0, true);
    });
    
    window.closeResultModal = function() {
        resultModal.classList.remove('show');
        resetGame(); // Reset to clean state
    };

    function renderMistakes() {
        const list = document.getElementById('mistakes-list-container'); list.innerHTML = '';
        btnPracticeAll.style.display = (mistakeList.length > 0) ? 'inline-block' : 'none';
        if (mistakeList.length === 0) { list.innerHTML = '<div class="empty-state">æš‚æ— é”™é¢˜ï¼ŒåŠ æ²¹ç»ƒä¹ ï¼</div>'; return; }
        mistakeList.forEach((item, index) => {
            const el = document.createElement('div'); el.className = 'mistake-item';
            el.innerHTML = `<div class="mistake-info" onclick="loadMistake(${index})"><div class="mistake-title">æ—‹å¾‹ #${index + 1}</div><div class="mistake-meta">${item.notes.length}ä¸ªéŸ³ Â· è·³è·ƒ ${item.jump}åº¦ Â· ${item.date}</div></div><button class="mistake-delete" onclick="deleteMistake(${index})">åˆ é™¤</button>`;
            list.appendChild(el);
        });
    }

    window.loadMistake = function(index, isAuto = false) {
        if (!isAuto) { isPracticeMode = false; practiceBadge.style.display = 'none'; scoreBoard.style.display = 'none';}
        const item = mistakeList[index]; if (!item) return; 
        melodyNotes = [...item.notes]; noteCount = melodyNotes.length; displayCount.textContent = noteCount;
        currentMelodyRhythmMode = RHYTHM_MODES[currentRhythmIndex].id;
        userPoints = new Array(noteCount).fill(null); isGameActive = true; isRevealed = false;
        btnCheck.style.display = 'flex'; btnCheck.disabled = true; btnNext.style.display = 'none'; btnPlayText.textContent = "é‡å¬";
        statusText.style.display = 'none'; mistakesModal.classList.remove('show'); resizeCanvas(); 
        setTimeout(() => playMelody(), 100);
    };

    window.deleteMistake = function(index) { mistakeList.splice(index, 1); localStorage.setItem('melody_mistakes', JSON.stringify(mistakeList)); renderMistakes(); };

    function saveMistake() {
        const now = new Date(); const dateStr = `${now.getMonth()+1}æœˆ${now.getDate()}æ—¥ ${now.getHours()}:${now.getMinutes()}`;
        const newItem = { notes: [...melodyNotes], jump: maxJumpDegree, date: dateStr };
        const exists = mistakeList.some(m => JSON.stringify(m.notes) === JSON.stringify(newItem.notes));
        if (!exists) { mistakeList.unshift(newItem); if (mistakeList.length > 50) mistakeList.pop(); localStorage.setItem('melody_mistakes', JSON.stringify(mistakeList)); }
    }

    // æ ¸å¿ƒåˆ¤å®šé€»è¾‘ï¼šç›¸å¯¹ä½ç½®ï¼ˆèµ°å‘ï¼‰åŒ¹é…å³æ­£ç¡®
    function evaluateAttempt() {
        let isWrong = false;
        // å®¹å·®å€¼ï¼šç§»é™¤ä¸¥æ ¼çš„ 0.03ï¼Œå› ä¸ºæˆ‘ä»¬ç°åœ¨åªå…³å¿ƒç›¸å¯¹æ–¹å‘
        // ä½†æ˜¯ä¸ºäº†é˜²æ­¢ç”»ç›´çº¿å¤ªéš¾ï¼Œè¿˜æ˜¯ä¿ç•™æå°çš„é˜²æŠ–åŠ¨
        const tolerance = 0.01; 
        
        for (let i = 0; i < melodyNotes.length - 1; i++) {
            // 1. æ—‹å¾‹å®é™…èµ°å‘: +1 (ä¸Šè¡Œ), -1 (ä¸‹è¡Œ), 0 (å¹³è¡Œ)
            // æ³¨æ„ï¼šMIDIå€¼è¶Šå¤§éŸ³è¶Šé«˜ã€‚
            const melDiff = melodyNotes[i+1] - melodyNotes[i];
            const melDir = Math.sign(melDiff); 

            // 2. ç”¨æˆ·ç»˜åˆ¶èµ°å‘
            // æ³¨æ„ï¼šç”»å¸ƒYåæ ‡è¶Šå°éŸ³è¶Šé«˜ã€‚æ‰€ä»¥è¦åè¿‡æ¥ï¼š(å‰ - å) > 0 ä»£è¡¨å‰æ¯”åå¤§(ä½)ï¼Œå³åæ¯”å‰å°(é«˜) -> ä¸Šè¡Œ
            if (userPoints[i] === null || userPoints[i+1] === null) { isWrong = true; break; }
            
            const userDiff = userPoints[i] - userPoints[i+1];
            let userDir = 0;
            
            if (Math.abs(userDiff) <= tolerance) { 
                userDir = 0; 
            } else {
                userDir = Math.sign(userDiff);
            }
            
            // 3. åªè¦æ–¹å‘ä¸€è‡´å°±ç®—å¯¹ (ä¸è€ƒè™‘å¹…åº¦)
            if (melDir !== userDir) { isWrong = true; break; }
        }
        return !isWrong;
    }

    function updateScoreBoard() {
        if (sessionTotal === Infinity) {
            scoreBoard.style.display = 'none';
        } else {
            scoreBoard.style.display = 'block';
            scoreBoard.textContent = `è¿›åº¦: ${sessionCurrent}/${sessionTotal} | æ­£ç¡®: ${sessionCorrect}`;
        }
    }

    function initDualPicker() { createPickerColumn('picker-start', startMidi, (val) => { startMidi = val; resetGame(); }); createPickerColumn('picker-end', endMidi, (val) => { endMidi = val; resetGame(); }); }
    function createPickerColumn(elementId, initialMidi, onUpdate) {
        const picker = document.getElementById(elementId);
        PIANO_KEYS.forEach((key, index) => {
            const div = document.createElement('div'); div.className = 'picker-item'; div.textContent = key.label;
            if (key.midi === initialMidi) div.classList.add('active');
            div.addEventListener('click', () => picker.scrollTo({ top: index * 34, behavior: 'smooth' }));
            picker.appendChild(div);
        });
        let isScrolling;
        picker.addEventListener('scroll', () => {
            const index = Math.round(picker.scrollTop / 34);
            if (index >= 0 && index < PIANO_KEYS.length) {
                const sel = PIANO_KEYS[index].midi;
                if (sel !== initialMidi) {
                    Array.from(picker.children).forEach(c => c.classList.remove('active'));
                    picker.children[index]?.classList.add('active'); playTickSound();
                    window.clearTimeout(isScrolling); isScrolling = setTimeout(() => onUpdate(sel), 200);
                }
            }
        });
    }

    function generateMelody() {
        melodyNotes = []; currentMelodyRhythmMode = RHYTHM_MODES[currentRhythmIndex].id;
        const rangeMin = Math.min(startMidi, endMidi); const rangeMax = Math.max(startMidi, endMidi);
        const validNotes = FULL_SCALE.filter(n => n >= rangeMin && n <= rangeMax);
        if (validNotes.length === 0) { melodyNotes = new Array(noteCount).fill(rangeMin); return; }
        let curr = validNotes[Math.floor(Math.random() * validNotes.length)];
        if (validNotes.length > 4) { const margin = Math.floor(validNotes.length * 0.2); curr = validNotes[margin + Math.floor(Math.random() * (validNotes.length - margin * 2))]; }
        for (let i = 0; i < noteCount; i++) {
            const span = (maxJumpDegree - 1) * 2 + 1; const currIdx = validNotes.indexOf(curr);
            let nextIdx = currIdx + Math.floor(Math.random() * span) - (maxJumpDegree - 1);
            if (nextIdx < 0) nextIdx = 0; if (nextIdx >= validNotes.length) nextIdx = validNotes.length - 1;
            if (nextIdx === currIdx && i > 0 && maxJumpDegree > 1 && Math.random() > 0.5) { nextIdx += (Math.random() > 0.5 ? 1 : -1); if (nextIdx < 0) nextIdx = 1; if (nextIdx >= validNotes.length) nextIndex = validNotes.length - 2; }
            curr = validNotes[nextIdx] || validNotes[0]; melodyNotes.push(curr);
        }
    }

    async function playMelody() {
        playSessionId++; const mySession = playSessionId;
        AudioEngine.stopAll();
        await AudioEngine.init();
        if (btnPlayText.textContent === "æ’­æ”¾" || btnPlayText.textContent === "é‡å¬") {
             const prevText = btnPlayText.textContent;
             btnPlayText.textContent = "åŠ è½½ä¸­";
             await AudioEngine.ensureSamplesLoaded();
             if (mySession !== playSessionId) return;
             btnPlayText.textContent = prevText === "æ’­æ”¾" ? "é‡å¬" : "é‡å¬"; 
        }
        if (!AudioEngine.ctx) return;
        const now = AudioEngine.ctx.currentTime; const noteDuration = 0.6; const mode = currentMelodyRhythmMode;
        melodyNotes.forEach((note, i) => { 
            let velocity = 1.0;
            if (mode === 'none') { velocity = 1.0; } 
            else if (mode === '2/4') { velocity = (i % 2 === 0) ? 1.5 : 0.4; } 
            else if (mode === '3/4') { velocity = (i % 3 === 0) ? 1.5 : 0.4; } 
            else if (mode === '4/4') { if (i % 4 === 0) velocity = 1.6; else if (i % 4 === 2) velocity = 1.1; else velocity = 0.4; } 
            else if (mode === 'offbeat') { velocity = (i % 2 !== 0) ? 1.5 : 0.4; }
            AudioEngine.playTone(note, now + i * noteDuration, noteDuration, velocity); 
        });
    }

    function drawCanvas() {
        if (!canvas.logicalWidth) return;
        const w = canvas.logicalWidth, h = canvas.logicalHeight, colW = w / noteCount;
        ctx.clearRect(0, 0, w, h);
        for (let i = 0; i < noteCount; i++) {
            if (i % 2 === 0) { ctx.fillStyle = '#fafafa'; ctx.fillRect(i * colW, 0, colW, h); }
            ctx.beginPath(); ctx.moveTo((i+1)*colW, 0); ctx.lineTo((i+1)*colW, h); ctx.strokeStyle = '#f0f0f0'; ctx.lineWidth = 1; ctx.stroke();
            ctx.fillStyle = '#ccc'; ctx.font = '12px Arial'; ctx.fillText(i + 1, i * colW + colW/2 - 4, h - 40);
        }
        if (!isGameActive) return;
        if (userPoints.some(p => p !== null)) {
            ctx.save(); ctx.setLineDash([4, 4]); ctx.strokeStyle = 'rgba(0, 122, 255, 0.2)'; ctx.lineWidth = 1;
            userPoints.forEach(p => { if (p !== null) { const y = p * h; ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(w, y); ctx.stroke(); }}); ctx.restore();
        }
        if (userPoints.some(p => p !== null)) drawPath(userPoints, '#007AFF', 3, false);
        if (isRevealed) {
            const min = Math.min(...melodyNotes), max = Math.max(...melodyNotes); const range = (max - min) || 12, pad = 0.2;
            const norm = melodyNotes.map(n => 1 - ((n - min) / range * (1 - 2*pad) + pad)); if (max === min) norm.fill(0.5);
            drawPath(norm, '#34C759', 3, true);
            ctx.font = 'bold 14px sans-serif'; ctx.textAlign = 'center'; ctx.textBaseline = 'bottom';
            norm.forEach((yRatio, i) => {
                const x = i * colW + colW / 2; const y = yRatio * h; const midi = melodyNotes[i];
                const label = NOTE_NAMES[midi % 12] + (Math.floor(midi / 12) - 1);
                let textY = y - 10; if (textY < 20) textY = y + 25;
                ctx.lineWidth = 3; ctx.strokeStyle = 'rgba(255, 255, 255, 0.9)'; ctx.strokeText(label, x, textY);
                ctx.fillStyle = '#2e7d32'; ctx.fillText(label, x, textY);
            });
        }
    }

    function drawPath(pts, color, width, dashed) {
        const w = canvas.logicalWidth, h = canvas.logicalHeight, colW = w / noteCount;
        ctx.beginPath(); ctx.strokeStyle = color; ctx.lineWidth = width; ctx.lineJoin = 'round'; ctx.lineCap = 'round'; ctx.setLineDash(dashed ? [6, 6] : []);
        let started = false;
        pts.forEach((p, i) => { if (p !== null) { const x = i * colW + colW/2, y = p * h; if (!started) { ctx.moveTo(x, y); started = true; } else ctx.lineTo(x, y); }});
        ctx.stroke(); ctx.setLineDash([]);
        pts.forEach((p, i) => { if (p !== null) { const x = i * colW + colW/2, y = p * h; ctx.beginPath(); ctx.fillStyle = '#fff'; ctx.arc(x, y, 6, 0, Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.fillStyle = color; ctx.arc(x, y, 4, 0, Math.PI*2); ctx.fill(); }});
    }

    function handleInput(cx, cy) {
        if (!isGameActive || isRevealed) return;
        const rect = canvas.getBoundingClientRect(); const colIdx = Math.floor((cx - rect.left) / (rect.width / noteCount));
        if (colIdx >= 0 && colIdx < noteCount) { userPoints[colIdx] = (cy - rect.top) / rect.height; btnCheck.disabled = false; statusText.style.display = 'none'; drawCanvas(); }
    }
    canvas.addEventListener('mousedown', e => handleInput(e.clientX, e.clientY));
    canvas.addEventListener('touchstart', e => { e.preventDefault(); handleInput(e.touches[0].clientX, e.touches[0].clientY); }, { passive: false });
    canvas.addEventListener('touchmove', e => { e.preventDefault(); handleInput(e.touches[0].clientX, e.touches[0].clientY); }, { passive: false });

    document.getElementById('btn-decrease').addEventListener('click', () => updateCount(-1));
    document.getElementById('btn-increase').addEventListener('click', () => updateCount(1));
    function updateCount(d) { let n = noteCount + d; if (n < 3) n = 3; if (n > 12) n = 12; if (n !== noteCount) { noteCount = n; displayCount.textContent = n; playTickSound(); resetGame(); } }
    document.getElementById('btn-jump-decrease').addEventListener('click', () => updateJump(-1));
    document.getElementById('btn-jump-increase').addEventListener('click', () => updateJump(1));
    function updateJump(d) { let n = maxJumpDegree + d; if (n < 2) n = 2; if (n > 8) n = 8; if (n !== maxJumpDegree) { maxJumpDegree = n; displayJump.textContent = n + "åº¦"; playTickSound(); resetGame(); } }
    document.getElementById('btn-inst-prev').addEventListener('click', () => updateInst(-1));
    document.getElementById('btn-inst-next').addEventListener('click', () => updateInst(1));
    function updateInst(d) { displayInst.textContent = AudioEngine.changeInstrument(d); playTickSound(); }
    document.getElementById('btn-rhythm-prev').addEventListener('click', () => updateRhythm(-1));
    document.getElementById('btn-rhythm-next').addEventListener('click', () => updateRhythm(1));
    function updateRhythm(d) { let n = currentRhythmIndex + d; if (n < 0) n = RHYTHM_MODES.length - 1; if (n >= RHYTHM_MODES.length) n = 0; currentRhythmIndex = n; displayRhythm.textContent = RHYTHM_MODES[n].name; playTickSound(); }
    document.getElementById('btn-qcount-prev').addEventListener('click', () => updateQCount(-1));
    document.getElementById('btn-qcount-next').addEventListener('click', () => updateQCount(1));
    function updateQCount(d) {
        let n = currentQCountIndex + d;
        if (n < 0) n = QUESTION_COUNTS.length - 1;
        if (n >= QUESTION_COUNTS.length) n = 0;
        currentQCountIndex = n;
        sessionTotal = QUESTION_COUNTS[n].val;
        displayQCount.textContent = QUESTION_COUNTS[n].label;
        // Reset Session
        sessionCurrent = 0; sessionCorrect = 0;
        updateScoreBoard();
        playTickSound();
    }

    function resetGame() {
        if (!isPracticeMode) {
            // Reset for new session start logic
            userPoints = new Array(noteCount).fill(null); melodyNotes = []; isGameActive = false; isRevealed = false;
            btnCheck.style.display = 'flex'; btnCheck.disabled = true; btnNext.style.display = 'none'; btnPlayText.textContent = "æ’­æ”¾";
            statusText.style.display = 'block'; practiceBadge.style.display = 'none';
            
            // New Session Reset
            if (sessionCurrent >= sessionTotal) {
                sessionCurrent = 0; sessionCorrect = 0;
            }
            updateScoreBoard();
            resizeCanvas();
        }
    }

    btnPlay.addEventListener('click', () => {
        AudioEngine.stopAll(); playSessionId++;
        if (!isGameActive) {
            // New Round
            if (!isPracticeMode && sessionCurrent < sessionTotal) {
                sessionCurrent++;
                updateScoreBoard();
            }
            
            generateMelody(); userPoints = new Array(noteCount).fill(null); isGameActive = true; isRevealed = false;
            btnCheck.style.display = 'flex'; btnCheck.disabled = true; btnNext.style.display = 'none'; 
            statusText.style.display = 'none'; resizeCanvas(); playMelody();
        } else { playMelody(); }
    });
    
    btnCheck.addEventListener('click', () => { 
        if(isGameActive) { 
            AudioEngine.stopAll(); playSessionId++; isRevealed = true; drawCanvas(); 
            btnCheck.style.display = 'none'; btnNext.style.display = 'flex'; 
            
            const isCorrect = evaluateAttempt();
            if (isCorrect) {
                showToast("å›ç­”æ­£ç¡®", "correct");
                if (!isPracticeMode) sessionCorrect++;
            } else {
                showToast("å›ç­”é”™è¯¯", "wrong");
                saveMistake();
            }
            updateScoreBoard();
        } 
    });
    
    btnNext.addEventListener('click', () => {
        AudioEngine.stopAll(); playSessionId++;
        if (isPracticeMode) {
            practiceIndex++;
            if (practiceIndex < mistakeList.length) { loadMistake(practiceIndex, true); }
            else { showToast("å¤ä¹ å®Œæˆï¼å›åˆ°æ™®é€šæ¨¡å¼"); isPracticeMode = false; resetGame(); }
        } else {
            // Check if session ended
            if (sessionCurrent >= sessionTotal) {
                // Show Result
                document.getElementById('result-score-text').textContent = Math.round((sessionCorrect / sessionTotal) * 100) + "%";
                document.getElementById('result-detail-text').textContent = `ç­”å¯¹ ${sessionCorrect} é¢˜ / å…± ${sessionTotal} é¢˜`;
                resultModal.classList.add('show');
            } else {
                // Next Question
                sessionCurrent++;
                updateScoreBoard();
                generateMelody(); userPoints = new Array(noteCount).fill(null); isGameActive = true; isRevealed = false;
                btnCheck.style.display = 'flex'; btnCheck.disabled = true; btnNext.style.display = 'none'; btnPlayText.textContent = "é‡å¬";
                statusText.style.display = 'none'; resizeCanvas(); playMelody();
            }
        }
    });

    setTimeout(() => { resizeCanvas(); initDualPicker(); AudioEngine.init(); }, 100);
</script>
</body>
</html>
